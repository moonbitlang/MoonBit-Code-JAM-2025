<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pair Matching Ê∏∏Êàè</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #e0f7fa, #f0f0f0);
      font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      margin: 0 0 12px;
      font-size: 28px;
      color: #2c3e50;
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .game-info {
      display: flex;
      gap: 20px;
      margin-bottom: 16px;
      font-size: 18px;
      color: #333;
    }

    #timer {
      font-weight: bold;
      color: #e74c3c;
    }

    #memoryCountdown {
      font-weight: bold;
      color: #27ae60;
    }

    #restart {
      padding: 8px 20px;
      font-size: 16px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 24px;
      cursor: pointer;
      transition: background 0.2s;
    }

    #restart:hover {
      background: #2980b9;
    }

    #restart:active {
      transform: scale(0.98);
    }

    #gameCanvas {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      display: block;
    }

    .loading {
      font-size: 18px;
      color: #7f8c8d;
      margin-top: 20px;
      height: 20px;
    }
  </style>
</head>

<body>
  <h1>Pair Matching Ê∏∏Êàè</h1>
  <div class="game-info">
    <div id="timer">Êó∂Èó¥: 0 Áßí</div>
    <div id="memoryCountdown"></div>
    <button id="restart">ÈáçÊñ∞ÂºÄÂßã</button>
  </div>
  <div class="loading" id="loading">Ê≠£Âú®Âä†ËΩΩÊ∏∏ÊàèËµÑÊ∫ê...</div>
  <canvas id="gameCanvas" width="600" height="700"></canvas>

  <!-- Èü≥ÊïàÔºàBase64Ôºâ -->
  <audio id="flipSound"
    src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhIeJi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8="></audio>
  <audio id="matchSound"
    src="data:audio/wav;base64,UklGRiQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQADAAABgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w=="></audio>
  <audio id="mismatchSound"
    src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="></audio>
  <audio id="winSound"
    src="data:audio/wav;base64,UklGRiADAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQADAAABgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w=="></audio>

  <script>
    const wasm = {
      get_card_symbol: null,
      is_card_flipped: null,
      is_card_matched: null,
      game_active: null,
      set_game_active: null,
      get_card_index: null,
      set_card_index: null,
      set_flip_card_false: null,
      set_flip_card_true: null,
      get_cols: null,
      get_rows: null,
      get_card_width: null,
      get_card_height: null,
      get_padding: null,
      check_match: null,
      reset_game: null,
      is_game_won: null
    };

    const loadingEl = document.getElementById('loading');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const timerEl = document.getElementById('timer');
    const memoryCountdownEl = document.getElementById('memoryCountdown');
    const restartBtn = document.getElementById('restart');

    const flipSound = document.getElementById('flipSound');
    const matchSound = document.getElementById('matchSound');
    const mismatchSound = document.getElementById('mismatchSound');
    const winSound = document.getElementById('winSound');

    let soundEnabled = true;
    let flipped = [];
    let startTime = null;
    let elapsedTime = 0;
    let timerInterval = null;
    let memoryPhase = false;

    // Èü≥ÊïàÂºÄÂÖ≥ÊåâÈíÆ
    const soundBtnX = canvas.width - 60;
    const soundBtnY = 16;
    const soundBtnSize = 36;

    const symbols = ['üçé', 'üçå', 'üçá', 'üçä', 'üçì', 'üçí', 'üçë', 'ü•ù'];

    function playSound(audio) {
      if (!soundEnabled) return;
      audio.currentTime = 0;
      audio.play().catch(e => console.log("Audio play failed:", e));
    }

    function drawSoundButton() {
      ctx.fillStyle = soundEnabled ? '#4CAF50' : '#f44336';
      ctx.beginPath();
      ctx.roundRect(soundBtnX, soundBtnY, soundBtnSize, soundBtnSize, 8);
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(soundEnabled ? 'üîä' : 'üîá', soundBtnX + soundBtnSize / 2, soundBtnY + soundBtnSize / 2);
    }

    function shuffleMatrix() {
      const rows = wasm.get_rows();
      const cols = wasm.get_cols();
      const total = rows * cols;
      const matrix = [];
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          matrix.push(wasm.get_card_symbol(i, j));
        }
      }

      for (let i = total - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [matrix[i], matrix[j]] = [matrix[j], matrix[i]];
      }

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          wasm.set_card_index(i, j, matrix[i * cols + j]);
        }
      }
    }

    function startMemoryPhase() {
      memoryPhase = true;
      let count = 5;
      memoryCountdownEl.textContent = `ËÆ∞ÂøÜÊó∂Èó¥: ${count} Áßí`;

      const countdownInterval = setInterval(() => {
        count--;
        if (count >= 0) {
          memoryCountdownEl.textContent = `ËÆ∞ÂøÜÊó∂Èó¥: ${count} Áßí`;
          draw();
        } else {
          clearInterval(countdownInterval);
          memoryCountdownEl.textContent = "";
          memoryPhase = false;
          // ÂêØÂä®Ê≠£ÂºèËÆ°Êó∂
          startTime = Date.now();
          timerInterval = setInterval(() => {
            elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            timerEl.textContent = `Êó∂Èó¥: ${elapsedTime} Áßí`;
          }, 1000);
          draw();
        }
      }, 1000);
    }

    function startGame() {
      clearInterval(timerInterval);
      flipped = [];
      startTime = null;
      elapsedTime = 0;
      wasm.set_game_active(true);
      timerEl.textContent = `Êó∂Èó¥: 0 Áßí`;
      memoryCountdownEl.textContent = "";
      canvas.style.opacity = "1";
      wasm.reset_game();
      shuffleMatrix();
      draw();
      setTimeout(startMemoryPhase, 100);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSoundButton();

      const rows = wasm.get_rows();
      const cols = wasm.get_cols();
      const cardWidth = wasm.get_card_width();
      const cardHeight = wasm.get_card_height();
      const padding = wasm.get_padding();
      const offsetX = (canvas.width - (cols * (cardWidth + padding) - padding)) / 2;
      const offsetY = (canvas.height - (rows * (cardHeight + padding) - padding)) / 2;

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const x = offsetX + j * (cardWidth + padding);
          const y = offsetY + i * (cardHeight + padding);
          const cardIndex = wasm.get_card_index(i, j);
          const isFlipped = wasm.is_card_flipped(i, j);        
          const isMatched = wasm.is_card_matched(i, j);        
          const showFront = memoryPhase || isFlipped || isMatched; 

          ctx.fillStyle = showFront ? '#fff' : '#555';
          ctx.beginPath();
          ctx.roundRect(x, y, cardWidth, cardHeight, 8);
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          if (showFront) {
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#333';
            ctx.fillText(symbols[cardIndex], x + cardWidth / 2, y + cardHeight / 2);
          }
        }
      }
    }

    canvas.addEventListener('click', e => {
      // ËÆ∞ÂøÜÈò∂ÊÆµÊàñÊ∏∏ÊàèÊú™ÊøÄÊ¥ªÊó∂Á¶ÅÊ≠¢Êìç‰Ωú
      if (memoryPhase || !wasm.game_active() || flipped.length >= 2) return;

      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      // Èü≥ÊïàÊåâÈíÆÁÇπÂáª
      if (
        clickX >= soundBtnX && clickX <= soundBtnX + soundBtnSize &&
        clickY >= soundBtnY && clickY <= soundBtnY + soundBtnSize
      ) {
        soundEnabled = !soundEnabled;
        draw();
        return;
      }

      const rows = wasm.get_rows();
      const cols = wasm.get_cols();
      const cardWidth = wasm.get_card_width();
      const cardHeight = wasm.get_card_height();
      const padding = wasm.get_padding();
      const offsetX = (canvas.width - (cols * (cardWidth + padding) - padding)) / 2;
      const offsetY = (canvas.height - (rows * (cardHeight + padding) - padding)) / 2;

      const gridX = clickX - offsetX;
      const gridY = clickY - offsetY;

      if (gridX < 0 || gridY < 0) return;

      const col = Math.floor(gridX / (cardWidth + padding));
      const row = Math.floor(gridY / (cardHeight + padding));

      if (row >= rows || col >= cols) return;

      // Â∑≤ÁøªÂºÄÊàñÂ∑≤ÂåπÈÖçÁöÑÂç°Áâå‰∏çÂèØÂÜçÁÇπ
      if (wasm.is_card_flipped(row, col) || wasm.is_card_matched(row, col)) return;

      wasm.set_flip_card_true(row, col);
      flipped.push([row, col]);
      playSound(flipSound);
      draw();

      if (flipped.length === 2) {
        setTimeout(() => {
          const [[r1, c1], [r2, c2]] = flipped;
          if (wasm.check_match(r1, c1, r2, c2)) {
            playSound(matchSound);
            if (wasm.is_game_won()) {
              wasm.set_game_active(false);
              clearInterval(timerInterval);
              playSound(winSound);
              setTimeout(() => {
                alert(`üéâ ÊÅ≠ÂñúÂÆåÊàêÔºÅÁî®Êó∂ ${elapsedTime} Áßí`);
                canvas.style.opacity = "0.6";
              }, 300);
            }
          } else {
            wasm.set_flip_card_false(r1, c1);
            wasm.set_flip_card_false(r2, c2);
            playSound(mismatchSound);
          }
          flipped = [];
          if (wasm.game_active()) draw();
        }, 600);
      }
    });

    restartBtn.addEventListener('click', startGame);

    // Polyfill for roundRect (for older browsers)
    if (!ctx.roundRect) {
      ctx.roundRect = function(x, y, width, height, radius) {
        if (radius === undefined) radius = 5;
        this.beginPath();
        this.moveTo(x + radius, y);
        this.lineTo(x + width - radius, y);
        this.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.lineTo(x + width, y + height - radius);
        this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.lineTo(x + radius, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.lineTo(x, y + radius);
        this.quadraticCurveTo(x, y, x + radius, y);
        this.closePath();
      };
    }

    // Load WASM
    WebAssembly.instantiateStreaming(
      fetch("target/wasm-gc/release/build/PairMatching.wasm")
    ).then(obj => {
      const exp = obj.instance.exports;
      Object.keys(wasm).forEach(key => {
        wasm[key] = exp[key];
      });

      loadingEl.textContent = "";
      startGame();
    }).catch(err => {
      loadingEl.textContent = "‚ùå Ê∏∏ÊàèÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü• WASM Êñá‰ª∂Ë∑ØÂæÑ";
      console.error("WASM Âä†ËΩΩÂ§±Ë¥•:", err);
    });
  </script>
</body>
</html>
